#!/usr/bin/env python
'''
map_ratios: The map_ratios module uses variant frequencies generated by map_counts to calculate enrichment ratios for each variant that occurs in both the unselected and selected map_counts output files.	 

The map_ratios module also uses a two-sided Possion exact test using the R poisson.test function to calculate a p-value for the significance of enrichment or depeletion for each variant and then performs multiple testing correction using the R qvalue function to produce a q-value.  
'''

import sys, time, math, os, optparse #import general libraries
import enrich_util #import project-specific libraries


__author__ = "Douglas M. Fowler"
__copyright__ = "Copyright 2011"
__credits__ = ["Douglas M Fowler", "Carlos L. Araya"]
__license__ = "FreeBSD"
__version__ = "0.2"
__maintainer__ = "Douglas M. Fowler"
__email__ = "dfowler@uw.edu"

try: #check to see if scipy is installed
	from scipy import stats

except:
	print 'Error: SciPy not present, p-values will be reported as NaN.'

try: # check to see if qvalue found
	import qvalue as qv

except:
	print 'Error: qvalue module not found, qvalues will be reported as NaN.'
	
def twotail_ptest(x, T, r, debug_flag=False):
	'''
	A slightly more advanced version of scipy's poisson test, to compensate for a time base and a two-sided test. Uses a two-sided p-test.
	A rewrite of poisson.test for R.
	'''
	m = r * T
	try:
		# Caching of scipy functions for quick calculation
		ppois = stats.poisson.cdf
		dpois = stats.poisson.pmf
		if m == 0:
			x == 0
		else:
			relErr = 1 + 1e-7
			d = dpois(x, r * T)

			if x == m:
				return 1
			elif x < m:
				N = int(math.ceil(2 * m - x))
				while (dpois(N, m) > d):
					N = 2 * N
				i = [index for index in xrange(int(math.ceil(m)), N+1)]
				y = len([z for z in i if dpois(z, m) <= d * relErr])
				return ppois(x, m) + (1-ppois(N-y, m))
			else:
				i = [index for index in xrange(0, int(math.floor(m) + 1))]
				y = len([z for z in i if dpois(z, m) <= d * relErr])
				return ppois(y-1, m) + (1-ppois(x - 1, m))

	except:
		return float('NaN')

def main(path, infile1, infile2, qc_filename, grid = 'L'):
	input_A_file = infile1
	input_B_file = infile2
	path = path

	if grid != 'L': #print logging information, if being called from the cluster
		print time.asctime(time.localtime())
		print path, infile1, infile2
		
	try:
		#build the standard dictionary for later printing:
		input_dict = enrich_util.build(path + 'data/output/' + input_A_file)
		
		#build a dictionary of the sequences and counts:
		norm_A_dict = enrich_util.build_value_dict(path + 'data/output/' + input_A_file, 0, 7, "float")
		norm_B_dict = enrich_util.build_value_dict(path + 'data/output/' + input_B_file, 0, 7, "float")
		
		count_A_dict = enrich_util.build_value_dict(path + 'data/output/' + input_A_file, 0, 8, "int")
		count_B_dict = enrich_util.build_value_dict(path + 'data/output/' + input_B_file, 0, 8, "int")
	
	except:
		print 'Error: failed to open input file(s)'
		return(1)


	sum_A_counts = sum(count_A_dict.values())
	sum_B_counts = sum(count_B_dict.values())
	
	#build a dictionary of the ratios beuence library counts:
	ratio_dict = enrich_util.gen_ratio_dict(norm_A_dict, norm_B_dict)
	poisson_dict = {}
	fdr_dict = {}
	
	#find variants that are in input, not in selected
	in_unsel_not_sel = set(norm_B_dict).difference(set(norm_A_dict))
		
	try:
		for key in ratio_dict: #for each ratio, calculate the poisson exact test pvalue using scipy
			count_A = count_A_dict[key]
			B_ratio = float(count_B_dict[key]) / float(sum_B_counts)
			poisval = twotail_ptest(count_A, sum_A_counts, B_ratio)
			poisson_dict[key] = poisval
	
	except:
		print 'Error: the poisson test function caused an error.  P-values will be reported as NaN.'
		for key in ratio_dict:
			poisson_dict[key] = float('NaN')

	try: #calculate the list of qvalues given the pvalue list, using the qvalue module
		keys = poisson_dict.keys()
		sorted_pvals = []
		[sorted_pvals.append(poisson_dict[key]) for key in keys] #generate a list of sorted pvalues (order is important here)
		qvals = qv.qvalue(sorted_pvals) #perform the qvalue analysis
		qvals = qvals['qvalues']
		for i in xrange(0, len(qvals)): #create a dictionary of qvalues
			fdr_dict[keys[i]] = qvals[i] 
			
	except:
		print 'Error: the qvalue module caused an error.  Qvalues will be reported as NaN.'
		qvals = []
		keys = poisson_dict.keys()
		for key in ratio_dict:
			fdr_dict[key] = float('NaN')

	bonferroni = len(poisson_dict) #calculate the Bonferroni correction factor
	
	#print to file the sequences, ratios and other data 
	f = open(path + 'data/output/' + 'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1], 'w')
	f_1 = open(path + 'data/output/' + 'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1] + '.m1', 'w')
	f_2 = open(path + 'data/output/' + 'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1] + '.m2', 'w')

	print >>f, '\t'.join(["seqID","sequence","match_count","mutation_count","mutation_location","mutation_identity","max_mutation_run","log2_ratio", "fractional_fitness", "fractional_wt", "pval", "bonferroni", "qval"])
	print >>f_1, '\t'.join(["seqID","sequence","match_count","mutation_count","mutation_location","mutation_identity","max_mutation_run","log2_ratio", "fractional_fitness", "fractional_wt", "pval", "bonferroni", "qval"])
	print >>f_2, '\t'.join(["seqID","sequence","match_count","mutation_count","mutation_location","mutation_identity","max_mutation_run","log2_ratio", "fractional_fitness", "fractional_wt", "pval", "bonferroni", "qval"])
	
	seqIDs = enrich_util.valuesort(ratio_dict)
	seqIDs.reverse()
	maxRatio = ratio_dict[seqIDs[0]]
	wtRatio = ratio_dict['NA-NA']
	count_m1 = 0
	count_m2 = 0
	for seqID in seqIDs:
		poisson = poisson_dict[seqID]
		fdr = fdr_dict[seqID]
		try:
			bf = poisson*bonferroni
			if bf > 1: #make sure Bonferroni pvalues do not exceed 1
				bf = 1
				
		except:
			bf = 'NA'
			
		print >>f, '\t'.join([seqID] + map(str, input_dict[seqID][:6] + [math.log(float(ratio_dict[seqID]),2), float(ratio_dict[seqID])/maxRatio, float(ratio_dict[seqID])/wtRatio] + [poisson, bf, fdr]))
		
		if input_dict[seqID][2] == '1':
			count_m1 += 1
			print >>f_1, '\t'.join([seqID] + map(str, input_dict[seqID][:6] + [math.log(float(ratio_dict[seqID]),2), float(ratio_dict[seqID])/maxRatio, float(ratio_dict[seqID])/wtRatio] + [poisson, bf, fdr]))
			
		if input_dict[seqID][2] == '2':
			count_m2 += 1
			print >>f_2, '\t'.join([seqID] + map(str, input_dict[seqID][:6] + [math.log(float(ratio_dict[seqID]),2), float(ratio_dict[seqID])/maxRatio, float(ratio_dict[seqID])/wtRatio] + [poisson, bf, fdr]))
			
	f.close()
	f_1.close()
	f_2.close()
	
	#export qc data to qc file
	qc_data = { 'variants-not-in-sel_'+infile2:list(in_unsel_not_sel), 'total-ratios-all_'+'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1]:len(seqIDs), 
		'total-ratios-m1_'+'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1] + '.m1': count_m1, 
		'total-ratios-m2_'+'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1] + '.m2': count_m2 }
	enrich_util.update_qc_file( path + 'qc/' + qc_filename, qc_data)
	
	return(0)
	
if __name__ == '__main__':
	
	parser = optparse.OptionParser()
	parser.add_option('--path', action = 'store', type = 'string', dest = 'path', help = 'exact location from / of runLayerA, with trailing /')
	parser.add_option('--infile1', action = 'store', type = 'string', dest = 'infile1', help = 'input filename, numerator')
	parser.add_option('--infile2', action = 'store', type = 'string', dest = 'infile2', help = 'input filename, denominator')
	parser.add_option('--local', action = 'store', type = 'string', dest = 'local', help = 'Is this a local (L) run or should an SGE (SGE) job be scheduled?')
	parser.add_option('--qc_filename', action = 'store', type = 'string', dest = 'qc_filename', help = 'Name of QC file ([CONFIGFILE].qc)')
	(option, args) = parser.parse_args()

	main(option.path, option.infile1, option.infile2, option.qc_filename, option.local)
